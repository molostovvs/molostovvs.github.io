[{"content":"warpd Что такое warpd? Из описания репозитория на github: интерфейс управления мышью с помощи клавиатуры. Более подробно с примерами использования можно ознакомиться тут: репозиторий на GitHub\nНа 17.03.2024 репозиторий на гитхабе имеет 2700 звездочек, а последний коммит в мастер был 10 месяцев назад. Есть несколько issues открытых с июня 2023, большинство из которых относится к работе warpd на Windows. То есть проект взрослый, и как говорится feature-complete.\nПроблема с раскладками Если на компьютере используется несколько раскладок, то warpd берет из них ту, которая выводится в localectl. Это приводит к тому, что если в системе установлена первой раскладка на русском (как это было в моем случае), то warpd --hint не работает совсем. А если пользователь использует в том числе qwerty и Dvorak, как в этом issue, то при нажатии на одну кнопку warpd в режиме hint воспринимает ее как другую. Этот issue помог мне понять, почему у меня warpd не работал совсем.\nРешение Решение оказалось простым - исправить скрипт, который устанавливает раскладки при запуске i3wm (оконный менеджер, которым я пользуюсь).\nСкрипт до:\n1 setxkbmap -layout ru,us -variant ,dvorak И скрипт после:\n1 setxkbmap -layout us,ru -variant dvorak, После этого изменения hint режим warpd работает как и должен.\n","date":"2024-03-17T18:00:00Z","image":"https://molostovvs.github.io/p/warpd-layout-fix/cover_hu4882d26001e81134e0fbe4a5f96029f9_917196_120x120_fill_box_smart1_3.png","permalink":"https://molostovvs.github.io/p/warpd-layout-fix/","title":"Warpd и русская раскладка на linux"},{"content":"BimPublisher как автоматизация Для Tekla есть самый популярный вариант полной автоматизации - это BimPublisher. Из названия понятно, что BimPublisher предназначен для публикации чего-то. И его даже можно использовать для других задач, не относящихся к экспорту. Для этих задач мы можем использовать макросы, которые запускаются перед экспортом (в BimPublisher это Run these macros before exports) и после экспорта (в BimPublisher это Run these macros after exports). Пример такой автоматизации можно найти в статье из раздела Tekla User Assistance про автоматическое обновление моделей из Model Sharing.\nПроблема BimPublisher Почему бы тогда не остановится на BimPublisher и пользоваться им для наших задач, зачем что-то придумывать? Проблема в том, что BimPublisher запускает Tekla с UI, который нужен человеку. Но у нас-то не будет никакого человека, который будет пользоваться Tekla, Tekla будет использоваться программой - т.е. нашим скриптом. Следовательно UI нам не нужен, но запуск Tekla и открытие модели большей частью состоит из загрузки UI.\nHeadless Tekla Решением проблемы является Headless Tekla, пример можно найти в официальном репозитории Trimble на GitHub. Headless Tekla находится в сборке Tekla.Structures.Service, а ее API не выпущен официально, поэтому в справке отсутствует документация. Но благодаря примеру можно быстро разобраться что к чему. Немного изменю файл Program.cs из примера и приведу его здесь с комментариями:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 var binDir = $@\u0026#34;C:\\TeklaStructures\\2022.0\\bin\u0026#34;; // Подписка на событие, которое возникает, когда не найдена dll. // Поскольку при запуске Tekla нужно много dll из папки /bin/, // мы их не копируем к нашему исполняемому файлу, // а просто указываем где .Net Framework искать dll, // которую он не нашел в папке с исполняемым файлом. AppDomain.CurrentDomain.AssemblyResolve += (_, args) =\u0026gt; FindAssembly(args, binDir); // Создаем экземпляр headless tekla, в этот момент происходит запуск Tekla using var service = new TSS.TeklaStructuresService( new DirectoryInfo(binDir), \u0026#34;ENGLISH\u0026#34;, new FileInfo( $@\u0026#34;C:\\TeklaStructures\\2022.0\\Environments\\default\\env_Default_environment.ini\u0026#34; ), new FileInfo($@\u0026#34;C:\\TeklaStructures\\2022.0\\Environments\\default\\role_Steel_Detailer.ini\u0026#34;) ); var modelPath = @\u0026#34;C:\\TeklaStructuresModels\\test-model\u0026#34;; service.Initialize(new DirectoryInfo(modelPath)); // После инициализации Tekla нам доступен API Console.WriteLine($\u0026#34;Connected: {new TSM.Model().GetConnectionStatus()}\u0026#34;); Console.WriteLine($\u0026#34;Model name: {new TSM.Model().GetInfo().ModelName}\u0026#34;); Console.ReadKey(); return; static Assembly FindAssembly(ResolveEventArgs args, string binDir) { var requestedAssembly = new AssemblyName(args.Name); var dllPath = Path.Combine(binDir, requestedAssembly.Name + \u0026#34;.dll\u0026#34;); return File.Exists(dllPath) ? Assembly.LoadFile(dllPath) : throw new ArgumentException(); } Этот код можно использовать чтобы открыть модель Tekla в headless режиме, после чего можно обращаться к открытой модели с помощью Tekla Open API. В следующей статье рассмотрим какие есть преимущества у этого подхода с точки зрения производительности.\n","date":"2024-02-21T07:00:00Z","image":"https://molostovvs.github.io/p/tekla-headless-p1/cover_hu3693dfcdecc2b977fb4b47838e85e5e0_304200_120x120_fill_box_smart1_3.png","permalink":"https://molostovvs.github.io/p/tekla-headless-p1/","title":"Headless? Ты что, голову дома забыл?"},{"content":"Что за конец года без выдачи документации? В это время особенно важно поддерживать коллег-инженеров. Можно отправить всем старое и скучное текстовое сообщение (но даже думать над текстом этого сообщения было бы скучно), а можно придумать что-то необычное и простое, как например шалость с лентой команд. Для этого пришлось расчехлить тяжелую артиллерию: много кнопок на ленте, Paint и пиксель-арт. Некоторые уже догадались: я сделал большое пиксельное \u0026ldquo;С новым годом!\u0026rdquo;!\nПроцесс был одновременно веселым и трогательным, а результат обещал быть очень милым. Если честно, я чувствовал себя цифровым Дедом Морозом, только в руках была мышка, которая ставила пиксели, а не посох, который обычно рисует узоры на окнах. Палитра состояла всего из 4 цветов, которые по очереди применялись к каждой букве, чтобы показать дух праздника (ну и сделать отсылку к гирлянде, конечно). Итогом моего творчества стала такая заготовка, из которой потом были созданы иконки 16x16 пикселей.\nИ вот во что они превратились в Tekla:\nФон оставил белым по совету супруги, у которой белые рамки ассоциировались с подарочными коробками.\nНеожиданный подарок от Tekla Но позже шалость получила продолжение! Оказалось, что Tekla отказывается праздновать новый год. Для одного счастливчика (или несчастливчика?) \u0026ldquo;Новый год\u0026rdquo; превратился в \u0026ldquo;Сома\u0026rdquo;:\nИзображения для кнопок загрузились не все, поэтому счастливчик смотрел на веселого и странного\u0026quot;Сома\u0026quot;. Вероятно это как-то связано с тем, что иконки для команд хранились в сетевом хранилище и к ним обращалось примерно 30 экземпляров Tekla одновременно.\nВот так, даже посреди серьезной работы одна шалость, созданная человеком, может превратиться в другую, которую создает нам программа. А в конце года уже пора расслабляться, принимать неожиданности и помнить - что смех лучшее лекарство, особенно в канун пиксельного нового года!\nВсех с новым годом!\n","date":"2023-12-31T00:00:00Z","image":"https://molostovvs.github.io/p/tekla-new-year/tree_hu16ff5703a26fe4d03e7498f0f7a34ed9_252_120x120_fill_box_smart1_3.png","permalink":"https://molostovvs.github.io/p/tekla-new-year/","title":"Новый год в Tekla"}]